#!/usr/bin/env bash
set -euo pipefail
source "$age_edit_cli_path/helpers"
key=""
ext="txt"
secret_name=""
namespace=""
use_passphrase=true

while [ $# -gt 0 ]; do
    case "$1" in
    -k | --key)
        key="$2"
        use_passphrase=false
        shift
        ;;
    -n | --namespace)
        namespace="$2"
        shift
        ;;
    -e | --ext)
        ext="$2"
        shift
        ;;
    -h | --help)
        display_logo
        echo "  Create a new secret."
        echo
        echo -e "  Usage: age-edit new <secret-name> [options]\n"
        echo "  Options:"
        echo "    -h, --help                            Show this help message."
        echo "    -n, --namespace                       The namespace directory to store secret in. Default: default"
        echo "    -k, --key                             Path to identity file for key-based decryption. Can alternatively provide age public key (age1...)."
        echo "    -e, --ext                             The file extension for the file when editing in editor. Use as way to improve syntax highlighting in your editor. Default: $ext"
        exit 0
        ;;
    *)
        if [ -z "$secret_name" ]; then
            secret_name="$1"
        else
            error "Invalid argument or option: '$1'." 1
        fi
        ;;
    esac
    shift
done

if [ -z "${EDITOR:-}" ]; then
    error "No EDITOR environment variable set. Please set it to your preferred text editor." 1
fi

if [ -z "$secret_name" ]; then
    error "No secret name provided. Please provide a secret name." 1
fi

# Validate secret name format
validate_secret_name "$secret_name"
context="$(get_cli_context)"

if [ -z "$namespace" ]; then
    namespace="default"
fi

secret_path=$(age_edit_context_path "items/$namespace/$secret_name.age")

if [ -f "$secret_path" ]; then
    error "Secret with name '$secret_name' already exists in namespace '$namespace'." 1
fi

mkdir -p "$(dirname "$secret_path")"

# if a key is provided, validate it
if [ -n "$key" ]; then
    if [ -f "$key" ]; then
        if ! age-keygen -y "$key" &>/dev/null; then
            error "Invalid identity file: $key" 1
        fi
    elif [[ "$key" == age1* ]]; then
        # It's a public key - basic format validation
        # Age public keys are age1 followed by 58 bech32 characters
        if [[ ! "$key" =~ ^age1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}$ ]]; then
            error "Invalid age public key format: $key" 1
        fi
    else
        error "Invalid key format. Must be an age public key (age1...) or path to identity file." 1
    fi
fi

rm -rf "$(tmp_path)"
mkdir -p "$(tmp_path "$context")"
tmp_file=$(mktemp $(tmp_path "$context/XXXXXX.$ext"))
trap 'rm -f "$tmp_file"' EXIT SIGINT SIGTERM

$EDITOR "$tmp_file"

# Check if file has any content
if [ ! -s "$tmp_file" ]; then
    error "No contents provided." 1
fi

info "Encrypting:"
encrypted_contents=$(encrypt_file "$tmp_file" "$key" "$use_passphrase")
printf "\033[1A\033[2K"

echo "$encrypted_contents" >"$secret_path"

success "Generated secret '$secret_name' in namespace '$namespace' in context '$context'."
