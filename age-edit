#!/usr/bin/env bash
# This script was generated by bashly 1.3.4 (https://bashly.dev)
# Modifying it manually is not recommended

if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
	printf "bash version 4.2 or higher is required\n" >&2
	exit 1
fi

version_command() {
	echo "$version"
}

age_edit_usage() {
	printf "age-edit - Manage secrets within your editor\n\n"

	printf "%s\n" "Usage:"
	printf "  age-edit COMMAND\n"
	printf "  age-edit [COMMAND] --help | -h\n"
	printf "  age-edit --version | -v\n"
	echo

	printf "%s\n" "Commands:"
	printf "  %s   Create a secret.\n" "new "
	printf "  %s   Edit a secret.\n" "edit"
	printf "  %s   List secrets.\n" "ls  "
	printf "  %s   Remove a secret.\n" "rm  "
	printf "  %s   Output a decrypted secret.\n" "get "
	echo

	if [[ -n "$long_usage" ]]; then

		printf "%s\n" "Options:"

		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

		printf "%s\n" "Environment Variables:"

		printf "  %s\n" "AGE_EDIT_CONTEXT"
		printf "    The context for managing different sets of secrets\n"
		printf "    %s\n" "Default: default"
		echo

	fi
}

age_edit_new_usage() {
	printf "age-edit new - Create a secret.\n\n"
	printf "Alias: n\n"
	echo

	printf "%s\n" "Usage:"
	printf "  age-edit new SECRET_NAME [OPTIONS]\n"
	printf "  age-edit new --help | -h\n"
	echo

	if [[ -n "$long_usage" ]]; then

		printf "%s\n" "Options:"

		printf "  %s\n" "--namespace, -n NAMESPACE"
		printf "    The namespace directory to store secret in\n"
		printf "    %s\n" "Default: default"
		echo

		printf "  %s\n" "--key, -k KEY"
		printf "    Path to identity file for key-based decryption. Can alternatively provide\n    age public key (age1...)\n"
		echo

		printf "  %s\n" "--ext, -e EXT"
		printf "    The file extension for the file when editing in editor. Use as way to\n    improve syntax highlighting in your editor\n"
		printf "    %s\n" "Default: txt"
		echo

		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		printf "%s\n" "Arguments:"

		printf "  %s\n" "SECRET_NAME"
		printf "    The name of the secret to create\n"
		echo

	fi
}

age_edit_edit_usage() {
	printf "age-edit edit - Edit a secret.\n\n"
	printf "Alias: e\n"
	echo

	printf "%s\n" "Usage:"
	printf "  age-edit edit SECRET_NAME [OPTIONS]\n"
	printf "  age-edit edit --help | -h\n"
	echo

	if [[ -n "$long_usage" ]]; then

		printf "%s\n" "Options:"

		printf "  %s\n" "--namespace, -n NAMESPACE"
		printf "    The namespace directory to store secret in\n"
		printf "    %s\n" "Default: default"
		echo

		printf "  %s\n" "--key, -k KEY"
		printf "    Path to identity file for key-based decryption\n"
		echo

		printf "  %s\n" "--ext, -e EXT"
		printf "    The file extension for the temporary file. Use as way to improve syntax\n    highlighting in your editor\n"
		printf "    %s\n" "Default: txt"
		echo

		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		printf "%s\n" "Arguments:"

		printf "  %s\n" "SECRET_NAME"
		printf "    The name of the secret to edit\n"
		echo

	fi
}

age_edit_ls_usage() {
	printf "age-edit ls - List secrets.\n\n"
	printf "Alias: l\n"
	echo

	printf "%s\n" "Usage:"
	printf "  age-edit ls [OPTIONS]\n"
	printf "  age-edit ls --help | -h\n"
	echo

	if [[ -n "$long_usage" ]]; then

		printf "%s\n" "Options:"

		printf "  %s\n" "--namespace, -n NAMESPACE"
		printf "    List secrets in specific namespace\n"
		echo

		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

age_edit_rm_usage() {
	printf "age-edit rm - Remove a secret.\n\n"
	printf "Alias: r\n"
	echo

	printf "%s\n" "Usage:"
	printf "  age-edit rm SECRET_NAME [OPTIONS]\n"
	printf "  age-edit rm --help | -h\n"
	echo

	if [[ -n "$long_usage" ]]; then

		printf "%s\n" "Options:"

		printf "  %s\n" "--namespace, -n NAMESPACE"
		printf "    The namespace the secret is stored in\n"
		printf "    %s\n" "Default: default"
		echo

		printf "  %s\n" "--force, -f"
		printf "    Force removal without confirmation\n"
		echo

		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		printf "%s\n" "Arguments:"

		printf "  %s\n" "SECRET_NAME"
		printf "    The name of the secret to remove\n"
		echo

	fi
}

age_edit_get_usage() {
	printf "age-edit get - Output a decrypted secret.\n\n"
	printf "Alias: g\n"
	echo

	printf "%s\n" "Usage:"
	printf "  age-edit get SECRET_NAME [OPTIONS]\n"
	printf "  age-edit get --help | -h\n"
	echo

	if [[ -n "$long_usage" ]]; then

		printf "%s\n" "Options:"

		printf "  %s\n" "--namespace, -n NAMESPACE"
		printf "    The namespace containing the secret\n"
		printf "    %s\n" "Default: default"
		echo

		printf "  %s\n" "--key, -k KEY"
		printf "    Path to identity file for key-based decryption\n"
		echo

		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		printf "%s\n" "Arguments:"

		printf "  %s\n" "SECRET_NAME"
		printf "    The name of the secret to get\n"
		echo

	fi
}

normalize_input() {
	local arg passthru flags
	passthru=false

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $passthru == true ]]; then
			input+=("$arg")
		elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		elif [[ "$arg" == "--" ]]; then
			passthru=true
			input+=("$arg")
		else
			input+=("$arg")
		fi

		shift
	done
}

#!/bin/bash

# Displays the logo
display_logo() {
		YELLOW='\033[1;33m'
		NC='\033[0m'
		echo -e "${YELLOW}
▄▀█ █▀▀ █▀▀ ▄▄ █▀▀ █▀▄ █ ▀█▀
█▀█ █▄█ ██▄    ██▄ █▄▀ █  █
${NC}"
}

remove_trailing() {
		value="$1"
		char="$2"
		echo "${value%"$char"}"
}

confirm() {
		echo -n "$(yellow_bold [CONFIRM]): $1 [y/n]: "
		read -r response
		[[ "$response" == [Yy] ]]
}

get_cli_context() {
		context="${AGE_EDIT_CONTEXT:-default}"
		echo "$context"
}

age_edit_context_path() {
		path="${1:-/}"
		context="$(get_cli_context)"
		base="$HOME/.age-edit/contexts/$context"
		path="$base/$path"
		echo "$(remove_trailing "$path" "/")"
}

tmp_path() {
		path="${1:-/}"
		base="/tmp/.age-edit"
		path="$base/$path"
		echo "$(remove_trailing "$path" "/")"
}

# Helper for printing in color
print_in_color() {
		local color="$1"
		shift
		if [[ -z ${NO_COLOR+x} ]]; then
				printf "$color%b\e[0m\n" "$*"
		else
				printf "%b\n" "$*"
		fi
}

# Color text helpers
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }

# Print error message and optionally exit
error() {
		exit_code="${2:-}"
		should_print="${3:-true}"
		if [ "$should_print" = true ]; then
				echo "$(red_bold [ERROR]): $1"
		fi
		if [ -n "$exit_code" ]; then
				exit $exit_code
		fi
}

# Print dry run message and optionally exit
dry_run() {
		exit_code="${2:-}"
		should_print="${3:-true}"
		if [ "$should_print" = true ]; then
				echo -e "$(yellow_bold [DRY RUN]): $1"
		fi
		if [ -n "$exit_code" ]; then
				exit $exit_code
		fi
}

# Print warning message and optionally exit
warning() {
		exit_code="${2:-}"
		should_print="${3:-true}"
		if [ "$should_print" = true ]; then
				echo -e "$(yellow_bold [WARNING]): $1"
		fi
		if [ -n "$exit_code" ]; then
				exit $exit_code
		fi
}

# Print success message
success() {
		should_print="${2:-true}"
		if [ "$should_print" = true ]; then
				echo -e "$(green_bold [SUCCESS]): $1"
		fi
}

# Print info message
info() {
		should_print="${2:-true}"
		if [ "$should_print" = true ]; then
				echo -e "$(cyan_bold [INFO]): $1"
		fi
}

# Encrypt file with age
encrypt_file() {
		local file_path="$1"
		local key="$2"
		local use_passphrase="$3"

		if [ "$use_passphrase" = true ]; then
				# Passphrase mode - prompt for passphrase
				age -p -a <"$file_path"
		else
				# Key-based mode - check if key is a file path or public key
				if [ -f "$key" ]; then
						# It's a file path to an identity file, extract public key
						local pubkey=$(age-keygen -y "$key" 2>/dev/null)
						if [ -z "$pubkey" ]; then
								error "Failed to extract public key from identity file: $key" 1
								return 1
						fi
						age -r "$pubkey" -a <"$file_path"
				elif [[ "$key" == age1* ]]; then
						# It's already a public key
						age -r "$key" -a <"$file_path"
				else
						error "Invalid key format. Must be an age public key (age1...) or path to identity file." 1
						return 1
				fi
		fi
}

# Validate secret name format (slug or snake_case)
validate_secret_name() {
		local name="$1"
		# Allow lowercase letters, numbers, hyphens, and underscores only
		# Must start with a letter
		if [[ ! "$name" =~ ^[a-z][a-z0-9_-]*$ ]]; then
				error "Invalid secret name format. Secret names must:
	- Start with a lowercase letter
	- Contain only lowercase letters, numbers, hyphens (-), and underscores (_)
	- Examples: 'db-password', 'api_key', 'prod-db-url'" 1
				return 1
		fi
		return 0
}

# Decrypt file with age
decrypt_file() {
		local file_path="$1"
		local key="$2"
		local use_passphrase="$3"

		if [ "$use_passphrase" = true ]; then
				# Passphrase mode - prompts for passphrase interactively
				age -d <"$file_path"
		else
				# Key-based mode - use identity file
				if [ ! -f "$key" ]; then
						error "Identity file not found: $key" 1
						return 1
				fi
				age -d -i "$key" <"$file_path"
		fi
}

age_edit_new_command() {

	secret_name="${args[secret_name]}"
	namespace="${args[--namespace]}"
	key="${args[--key]:-}"
	ext="${args[--ext]}"
	use_passphrase=true

	# Set use_passphrase based on whether key was provided
	if [ -n "$key" ]; then
			use_passphrase=false
	fi

	if [ -z "${EDITOR:-}" ]; then
			error "No EDITOR environment variable set. Please set it to your preferred text editor." 1
	fi

	# Validate secret name format
	validate_secret_name "$secret_name"
	context="$(get_cli_context)"

	secret_path=$(age_edit_context_path "items/$namespace/$secret_name.age")

	if [ -f "$secret_path" ]; then
			error "Secret with name '$secret_name' already exists in namespace '$namespace'." 1
	fi

	mkdir -p "$(dirname "$secret_path")"

	# if a key is provided, validate it
	if [ -n "$key" ]; then
			if [ -f "$key" ]; then
					if ! age-keygen -y "$key" &>/dev/null; then
							error "Invalid identity file: $key" 1
					fi
			elif [[ "$key" == age1* ]]; then
					# It's a public key - basic format validation
					# Age public keys are age1 followed by 58 bech32 characters
					if [[ ! "$key" =~ ^age1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}$ ]]; then
							error "Invalid age public key format: $key" 1
					fi
			else
					error "Invalid key format. Must be an age public key (age1...) or path to identity file." 1
			fi
	fi

	rm -rf "$(tmp_path)"
	mkdir -p "$(tmp_path "$context")"
	tmp_file=$(mktemp $(tmp_path "$context/XXXXXX.$ext"))
	trap 'rm -f "$tmp_file"' EXIT SIGINT SIGTERM

	$EDITOR "$tmp_file"

	# Check if file has any content
	if [ ! -s "$tmp_file" ]; then
			error "No contents provided." 1
	fi

	info "Encrypting:"
	encrypted_contents=$(encrypt_file "$tmp_file" "$key" "$use_passphrase")
	printf "\033[1A\033[2K"

	echo "$encrypted_contents" >"$secret_path"

	success "Generated secret '$secret_name' in namespace '$namespace' in context '$context'."

}

age_edit_edit_command() {

	#!/bin/bash

	# Variables from bashly args
	secret_name="${args[secret_name]}"
	namespace="${args[--namespace]:-default}"
	key="${args[--key]:-}"
	ext="${args[--ext]:-txt}"
	use_passphrase=true

	# Set use_passphrase based on whether key was provided
	if [ -n "$key" ]; then
			use_passphrase=false
	fi

	if [ -z "${EDITOR:-}" ]; then
			error "No EDITOR environment variable set. Please set it to your preferred text editor." 1
	fi

	# Strip .age extension if provided
	secret_name="${secret_name%.age}"

	# Validate secret name format
	validate_secret_name "$secret_name"

	context="$(get_cli_context)"

	secret_path=$(age_edit_context_path "items/$namespace/${secret_name}.age")

	if [ ! -f "$secret_path" ]; then
			error "Secret with name '$secret_name' does not exist in namespace '$namespace'." 1
	fi

	# Validate the key exists
	if [ -n "$key" ]; then
			if [ -f "$key" ]; then
					if ! age-keygen -y "$key" &>/dev/null; then
							error "Invalid identity file: $key" 1
					fi
			else
					error "Key must be a path to an identity file for decryption." 1
			fi
	fi

	# Decrypt the secret
	rm -rf "$(tmp_path)"
	mkdir -p "$(tmp_path "$context")"
	tmp_file=$(mktemp $(tmp_path "$context/XXXXXX.$ext"))
	trap 'rm -f "$tmp_file"' EXIT SIGINT SIGTERM

	info "Decrypting:"
	decrypt_file "$secret_path" "$key" "$use_passphrase" >"$tmp_file"

	printf "\033[1A\033[2K"

	$EDITOR "$tmp_file"

	# Check if file has any content
	if [ ! -s "$tmp_file" ]; then
			error "No contents provided." 1
	fi

	info "Encrypting:"
	encrypted_contents=$(encrypt_file "$tmp_file" "$key" "$use_passphrase")
	printf "\033[1A\033[2K"

	echo "$encrypted_contents" >"$secret_path"

	success "Updated secret '$secret_name' in namespace '$namespace' in context '$context'."

}

age_edit_ls_command() {

	#!/bin/bash

	# Variables from bashly args
	namespace="${args[--namespace]:-}"

	declare -A secrets=()
	context="$(get_cli_context)"

	if [ -n "$namespace" ]; then
			secrets_path=$(age_edit_context_path "items/$namespace")
	else
			secrets_path=$(age_edit_context_path "items")
	fi

	for file in $(find "$secrets_path" -type f 2>/dev/null); do
			namespace="$(basename "$(dirname "$file")")"
			name="$(basename "$file")"
			name="${name%.age}"
			if [[ -z ${secrets[$namespace]+_} ]]; then
					secrets[$namespace]=""
			fi

			secrets[$namespace]="${secrets[$namespace]} $name"
	done

	if [ ${#secrets[@]} -eq 0 ]; then
			warning "No secret items found in context '$(green_bold "$context")'." 1
	fi

	for ns in "${!secrets[@]}"; do
			items=()
			for item in ${secrets[$ns]}; do
					items+=("$item")
			done

			max_len=0
			item=""
			border=""
			min_width=40

			# Find the longest string
			for item in "${items[@]}"; do
					((${#item} > max_len)) && max_len=${#item}
			done

			((max_len < min_width)) && max_len=$min_width
			# Build border
			border="  +-$(printf '%*s' "$max_len" '' | tr ' ' '-')-+"
			# Print table
			echo "$border"
			echo "  | $(printf '%-*s' "$max_len" "Namespace: $ns") |"
			echo "$border"
			for item in "${items[@]}"; do
					printf "  | %-${max_len}s |\n" "$item"
			done
			echo "$border"

			echo -e "\n"
	done

}

age_edit_rm_command() {

	#!/bin/bash

	# Variables from bashly args
	secret_name="${args[secret_name]}"
	namespace="${args[--namespace]:-default}"
	force="${args[--force]:-}"

	context="$(get_cli_context)"

	secret_name="${secret_name%.age}" # Strip .age if provided
	validate_secret_name "$secret_name"
	secret_path=$(age_edit_context_path "items/$namespace/${secret_name}.age")

	if [ ! -f "$secret_path" ]; then
			error "Secret with name '$secret_name' doesnt exist in namespace '$namespace'." 1
	fi

	if [[ -z "$force" ]] && ! confirm "Are you sure you want to remove '$secret_name' from your stored secrets?"; then
			warning "Aborted." 1
	fi

	rm -f "$secret_path"
	success "Removed secret '$secret_name' in namespace '$namespace' in context '$context'."

}

age_edit_get_command() {

	secret_name="${args[secret_name]}"
	namespace="${args[--namespace]:-default}"
	key="${args[--key]:-}"
	use_passphrase=true

	# Set use_passphrase based on whether key was provided
	if [ -n "$key" ]; then
			use_passphrase=false
	fi

	secret_name="${secret_name%.age}" # Strip .age if provided
	validate_secret_name "$secret_name"

	# Build paths
	context="$(get_cli_context)"

	secret_path=$(age_edit_context_path "items/$namespace/${secret_name}.age")

	# Check secret exists
	if [ ! -f "$secret_path" ]; then
			error "Secret with name '$secret_name' does not exist in namespace '$namespace'." 1
	fi

	# Validate key if provided
	if [ -n "$key" ]; then
			if [ -f "$key" ]; then
					if ! age-keygen -y "$key" &>/dev/null; then
							error "Invalid identity file: $key" 1
					fi
			else
					error "Key must be a path to an identity file for decryption." 1
			fi
	fi

	# Decrypt and output to console
	decrypt_file "$secret_path" "$key" "$use_passphrase"

}

parse_requirements() {
	local key

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				age_edit_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	export AGE_EDIT_CONTEXT="${AGE_EDIT_CONTEXT:-default}"

	env_var_names+=("AGE_EDIT_CONTEXT")

	action=${1:-}

	case $action in
		-*) ;;

		new | n)
			action="new"
			shift
			age_edit_new_parse_requirements "$@"
			shift $#
			;;

		edit | e)
			action="edit"
			shift
			age_edit_edit_parse_requirements "$@"
			shift $#
			;;

		ls | l)
			action="ls"
			shift
			age_edit_ls_parse_requirements "$@"
			shift $#
			;;

		rm | r)
			action="rm"
			shift
			age_edit_rm_parse_requirements "$@"
			shift $#
			;;

		get | g)
			action="get"
			shift
			age_edit_get_parse_requirements "$@"
			shift $#
			;;

		"")
			age_edit_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)

				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

age_edit_new_parse_requirements() {
	local key

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				age_edit_new_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	action="new"

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			--namespace | -n)

				if [[ -n ${2+x} ]]; then
					args['--namespace']="$2"
					shift
					shift
				else
					printf "%s\n" "--namespace requires an argument: --namespace, -n NAMESPACE" >&2
					exit 1
				fi
				;;

			--key | -k)

				if [[ -n ${2+x} ]]; then
					args['--key']="$2"
					shift
					shift
				else
					printf "%s\n" "--key requires an argument: --key, -k KEY" >&2
					exit 1
				fi
				;;

			--ext | -e)

				if [[ -n ${2+x} ]]; then
					args['--ext']="$2"
					shift
					shift
				else
					printf "%s\n" "--ext requires an argument: --ext, -e EXT" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)

				if [[ -z ${args['secret_name']+x} ]]; then
					args['secret_name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	if [[ -z ${args['secret_name']+x} ]]; then
		printf "missing required argument: SECRET_NAME\nusage: age-edit new SECRET_NAME [OPTIONS]\n" >&2

		exit 1
	fi

	[[ -n ${args['--namespace']:-} ]] || args['--namespace']="default"
	[[ -n ${args['--ext']:-} ]] || args['--ext']="txt"

}

age_edit_edit_parse_requirements() {
	local key

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				age_edit_edit_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	action="edit"

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			--namespace | -n)

				if [[ -n ${2+x} ]]; then
					args['--namespace']="$2"
					shift
					shift
				else
					printf "%s\n" "--namespace requires an argument: --namespace, -n NAMESPACE" >&2
					exit 1
				fi
				;;

			--key | -k)

				if [[ -n ${2+x} ]]; then
					args['--key']="$2"
					shift
					shift
				else
					printf "%s\n" "--key requires an argument: --key, -k KEY" >&2
					exit 1
				fi
				;;

			--ext | -e)

				if [[ -n ${2+x} ]]; then
					args['--ext']="$2"
					shift
					shift
				else
					printf "%s\n" "--ext requires an argument: --ext, -e EXT" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)

				if [[ -z ${args['secret_name']+x} ]]; then
					args['secret_name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	if [[ -z ${args['secret_name']+x} ]]; then
		printf "missing required argument: SECRET_NAME\nusage: age-edit edit SECRET_NAME [OPTIONS]\n" >&2

		exit 1
	fi

	[[ -n ${args['--namespace']:-} ]] || args['--namespace']="default"
	[[ -n ${args['--ext']:-} ]] || args['--ext']="txt"

}

age_edit_ls_parse_requirements() {
	local key

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				age_edit_ls_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	action="ls"

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			--namespace | -n)

				if [[ -n ${2+x} ]]; then
					args['--namespace']="$2"
					shift
					shift
				else
					printf "%s\n" "--namespace requires an argument: --namespace, -n NAMESPACE" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)

				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

age_edit_rm_parse_requirements() {
	local key

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				age_edit_rm_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	action="rm"

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			--namespace | -n)

				if [[ -n ${2+x} ]]; then
					args['--namespace']="$2"
					shift
					shift
				else
					printf "%s\n" "--namespace requires an argument: --namespace, -n NAMESPACE" >&2
					exit 1
				fi
				;;

			--force | -f)

				args['--force']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)

				if [[ -z ${args['secret_name']+x} ]]; then
					args['secret_name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	if [[ -z ${args['secret_name']+x} ]]; then
		printf "missing required argument: SECRET_NAME\nusage: age-edit rm SECRET_NAME [OPTIONS]\n" >&2

		exit 1
	fi

	[[ -n ${args['--namespace']:-} ]] || args['--namespace']="default"

}

age_edit_get_parse_requirements() {
	local key

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				age_edit_get_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	action="get"

	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			--namespace | -n)

				if [[ -n ${2+x} ]]; then
					args['--namespace']="$2"
					shift
					shift
				else
					printf "%s\n" "--namespace requires an argument: --namespace, -n NAMESPACE" >&2
					exit 1
				fi
				;;

			--key | -k)

				if [[ -n ${2+x} ]]; then
					args['--key']="$2"
					shift
					shift
				else
					printf "%s\n" "--key requires an argument: --key, -k KEY" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)

				if [[ -z ${args['secret_name']+x} ]]; then
					args['secret_name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	if [[ -z ${args['secret_name']+x} ]]; then
		printf "missing required argument: SECRET_NAME\nusage: age-edit get SECRET_NAME [OPTIONS]\n" >&2

		exit 1
	fi

	[[ -n ${args['--namespace']:-} ]] || args['--namespace']="default"

}

initialize() {
	declare -g version="0.1.0"
	set -euo pipefail

	export AGE_EDIT_CONTEXT="${AGE_EDIT_CONTEXT:-default}"

	declare -g version="0.1.0"
	export AGE_EDIT_CLI_VERSION="$version"
	export AGE_EDIT_CLI_PATH="$(cd -- "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

	if ! command -v age >/dev/null 2>&1; then
			error "age is required but not installed. Please install age and try again. See: https://github.com/FiloSottile/age" 1
	fi

	if [[ -v command_line_args ]]; then
			if [[ " ${command_line_args[*]} " == *" --help "* || " ${command_line_args[*]} " == *" -h "* ]]; then
					display_logo
			fi
	else
			display_logo
	fi

}

run() {

	declare -g long_usage=''
	declare -g -A args=()
	declare -g -A deps=()
	declare -g -a env_var_names=()
	declare -g -a input=()

	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"new") age_edit_new_command ;;
		"edit") age_edit_edit_command ;;
		"ls") age_edit_ls_command ;;
		"rm") age_edit_rm_command ;;
		"get") age_edit_get_command ;;
	esac
}

command_line_args=("$@")
initialize
run "${command_line_args[@]}"
